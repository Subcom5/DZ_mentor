/*
 *  ДЗ
 *  1. Указатели на функции,
 *  2. Указатели как параметры функции
 *  3. Функции возвращающие указатели или ссылки
 *  4. Арифметика указателей
 *
 */
#include <iostream>
using std::cout, std::endl;

int sum(int a, int b){
    return a + b;
}

int multiplication(int a, int b){
    return a * b;
}

double div(double a, double b){
    return a / b;
}

void foo(int a){
    a++;
    cout << "foo() = " << a << endl;
}

void foo2(int *a){
    (*a)++;
    cout.width(10);
    cout << "foo2() = " << a << endl;
    cout.width(10);
    cout << "foo2() = " << *a << endl;
}



int main()
{
    setlocale(LC_ALL, "ru");

/*~~~~~~~~~~~~~~~~~Указатели на функции~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
    cout << "~~~~Указатели на функции~~~~`" << endl;

    // имя функции - это указатель на функцию
    printf("sum = %p\n", sum);

    int (*ptr_sum)(int, int); // указатель на функцию

    ptr_sum = sum; // инициализировали указатель функцией sum

    int result;
    result = sum(2,4);
    cout << result << endl;
    result = ptr_sum(2,4);
    cout << result << endl;

    ptr_sum = multiplication; // можем ссылаться на любую функцию с одинаковой сигнатурой

    result = ptr_sum(2,4);
    cout << result << "\n\n" << endl;

    //ptr_sum = div; // Несовпадение типов - Error

/*~~~~~~~~~~~~Указатели как параметры функции~~~~~~~~~~~~~~~~~~~~~~~*/
    cout << "~~~~Указатели как параметры функции~~~~~" << endl;

    int test = 5;
    // передаем значение переменной test в качестве аргумента в функцию foo (передача по значению)
    foo(test);
    // убеждаемся, что переменная test не изменилась, поскольку
    // при передачи аргумента в функцию  произошло копирование адреса test
    cout << "test = " << test << "\n" << endl;

    // передаем значение переменной test в качестве аргумента в функцию foo (передача по указателю)
    foo2(&test);
    // убеждаемся, что переменная test изменилась, поскольку
    // они обе хранят адрес на один и тот же участок памяти
    cout.width(10);
    cout << "test = " << &test << endl;
    cout.width(10);
    cout << "test = " << test << endl;

    // int foo_const(const int *a){}
    // по константному параметру нельзя изменить значение,
    // но можно изменить адрес указателя

    // int foo_const(const int const *a){}
    // по константному указателю на константу нельзя изменить ни
    // значение ни адрес

    // ссылка в отличии от указателя всегда ссылается на что-то,
    // в то время как указатель может иметь значение nullptr

    // поскольку имя массива это указатель на его первый элемент,
    // ты мы можем передать в функцию указатель на массив
    // foo_arr(size_arr s, int arr []){}
    cout << "\n\n" << endl;

    /*~~~~~~~~~~~~~~~~Функции возвращающие указатели или ссылки~~~~~~~~~~~~~~~~~~~*/

    // функциии могут возвращать значение по указателю и по ссылке
    int *foo3(int *a, int *b);
    int &foo4(int &a, int &b);

    // нельзя возвращать из функции адрес автоматической локальной переменной
    // так как она будет удалена по завершению функции

    /*~~~~~~~~~~~~~~Арифметика указателей~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

    int num1 = 4;
    int *ptr1 = &num1;
    cout << ptr1 << endl;
    // с указателями можем выполнять целочисленные операции
    // адрес указателя увеличивается на размер типа данных, для которого он объявлен
    ptr1 +=3;
    cout << ptr1 << endl;
    ptr1 -= 5;
    cout << ptr1 << endl;
    ptr1++;
    cout << ptr1 << endl;
    ptr1--;
    cout << ptr1 << endl << endl;

    int arr1[]{1, 3, 4, 7, 8};
    int *ptr_arr = &arr1[2];
    ptr_arr += 2;

    cout << *ptr_arr << endl;
    cout << ptr_arr << endl;

}














